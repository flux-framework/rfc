4/Flux Resource Model
=====================

The Flux Resource Model describes the conceptual model used for
resources within the Flux framework.

* Name: github.com/flux-framework/rfc/spec_4.adoc
* Editor: Mark Grondona <mgrondona@llnl.gov>
* State: draft

== Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to
be interpreted as described in http://tools.ietf.org/html/rfc2119[RFC 2119].

== Background

As in traditional resource management software, the Flux framework
requires a method for the description, configuration, tracking, and
assignment of consumable and other resources in the system being
managed. The Flux Framework, however, requires a more generalized and
flexible definition of resources and overall approach. This document
describes the basic resource model used by Flux, and how it relates
to other resource management components. We term the model for
describing resources in Flux _The Flux Resource Model_.

== Goals

The Flux Resource Model provides a common conceptual model for resources
described and managed by the Flux framework and its components. The
goals of this model are to:

* Develop a generalized, extensible model for resources within the framework
  such that all present and future resource types fit the model
* Provide a common configuration scheme for these resources
* Provide a common storage, access, modification and discovery APIs for
  managing resource information

== Related Standards

link:spec_14{outfilesuffix}[14/Canonical Job Specification]

== Design

The sections below describe in detail the Flux Resource Model
and its related specifications and APIs.

=== Conceptual Model: The Composite Resource Pool

The fundamental model for resources in the Flux framework is
the _composite resource pool_.  All resources MAY be modeled
using this concept, which is the combination of a _composite type_
(resources with 0 or more children arranged in a hierarchical
``has-a'' relationship), and a _resource pool_, which allows
the grouping of 1 or more _indistinct_ resources into a pool
with a given size.

This conceptual model leads to the natural representation of
resources in Flux as a hierarchy of individual or pooled resources
bound to a _root_ which will typically be a ``cluster'' or ``center''
resource.

Use of the composite pool model for resources in Flux has the
following nice properties:

* Groups of related resources are treated the same as a single instance
* A subset of a composite resource pool is a valid composite resource pool
* Composite resource naturally describes resources in a ``has-a'' relationship
* High level resources can be created piece-wise from base resource types.

=== Composite Resource Pool Representation

The representation of resources within the Flux framework SHALL
allow resources to be modeled as _composite pools_, and thus SHALL
store basic resource _pool_ data (attributes of resource) as well
as _composite_ data (hierarchical parent/child or ``has-a'' relationship
between resources).  Data required to be stored, tracked, and queried
is detailed in sections below.

The Flux Resource Model SHALL support a range of resource sets, from
all of the resources in the center to a small subset allocated to one
Flux instance.

The Flux Resource Model SHALL support multi-granularity scheduling and
management schemes. In such a scheme, the higher the Flux instance is
in the Flux hierarchy, the coarser resource granularity it MAY be
configured to operate at. For example, a higher-order Flux instance
MAY be configured to operate at the racks and aggregates on their
containing nodes while a lower-level instance MAY actually operate at
the nodes and cores as the finest resource granularity.

==== Resource Pool Data

* Type
* UUID (Unique ID for this resource)
* Basename
* Name
* ID (optional numeric ID to be appended to basename to get name)
* Properties (static properties associated with this instance)
* Tags (dynamic list of tags)
* Size (Total number of resources in this pool)
* Units (optional units associated with the `size` value)
* State (e.g., up, down, degraded, failing, unknown, null)
* Composite resource data (see below)
* Graph data (see below)
* Resource allocation data (see below)

The default value for `basename` is the `type`.  The default value for
`name` is a concatenation of `basename` and `ID`, or just `basename`
when the `ID` value is not assigned.

The value for `name` SHALL support arbitrary resource attributes and
properties (e.g. a system might have node names formatted like
"node-${frameid}-${rack}").

The value for `properties` SHALL support multiple identifying
properties which could be used to uniquely characterize the resource.

==== Composite Resource Data

* URI (in ``name:/path/to/resource'' form)
* Children
* Parent
* UUID of resource pool (or other pointer to resource data)

==== Resource Graph Data

Resource pools MAY be associated with other resource pools that are
not members of the same composite hierarchy.  These relationships
SHALL be modeled with graphs.  The graph data SHALL contain links to
vertices in other graphs to which the resource is associated.
Examples include graphs that model power distribution or network
topology.

==== Resource Allocation Data

For the discussion that follows, the term _job_ is to be interpreted
as described in link:spec_8{outfilesuffix}[8/Flux Task and Program
Execution Services]

* Exclusive flag - all `size` elements of resource pool MUST be
  allocated to job when set
* Staged (temporary lock when this resource is being considered for a job)
* Allocations  - List of jobs (with `size`) to which this resource is allocated
* Reservations - List of jobs (with `size`) to which this resource is reserved
* Shared       - List of jobs (without `size`) sharing this resource

Allocations, reservations and shared change over the course of time.
The allocations, reservations and shared data MAY become an array of
job allocations, reservations and shared over time to support
scheduling jobs in the future.

== Composite Resource Pool Methods

When operating on a resource as an object, the following methods
SHALL be supported.

=== Load / Save

Serialize:: A method for serializing/deserializing a resource pool and
 its children SHALL be provided to allow for transmission for resource
 pool hierarchy and data over the wire, saving state to a file, etc.

=== Copying and Destroying

These methods below MAY be limited to the composite resource pool and
not the associated graphs.

Copy:: A method for copying a resource composite to a new instance SHALL
 be provided. This method MAY be used to create a new instance of
 resource description to pass to a sub-job within a Flux instance. The basic
 Copy operation SHALL copy the tree rooted at the current resource,
 pruned of all unavailable resources, as well as all resources
 back to the root of the hierarchy. When copying a resource to a new
 instance, the implementation SHALL copy only _available_ resources
 to the new instance. That is, resource pools with no available
 resources (and their children) SHALL be ignored during a copy,
 and copied resources SHALL have `size` set to _available_ and
 _allocated_ set to zero.

Duplicate:: A method for duplicating an entire hierarchy SHALL be
 provided. This method SHALL return a copy of of an existing hierarchy
 without any other unnecessary changes.

Merge:: A method for merging one Resource Pool into another SHALL be
 provided. The _Merge_ method SHALL allow a Resource Pool at one URI
 to be merged with another Resource Pool Hierarchy at a specified
 ``path'' or new URI. The method SHALL attach the new hierarchy at
 the common ancestor. This method MAY be used by the implementation
 to grow a job resource pool, as in a grow operation for a job.

Unlink:: A method for removing or ``unlinking'' a resource from a hierarchy
 SHALL be provided. This method SHALL remove the current resource from
 the _children_ list of its parent, and remove the current hierarchy
 or topology from the Hierarchy table in the corresponding Resource pool
 data table. If there are no more entries in this Resource's Hierarchy
 table, then the Resource data object MAY be garbage collected.

=== Resource Pool Data Methods

Size:: A method to query the size of a resource pool SHALL be
 provided.

Tag (K, [V]):: A method for tagging resource pools with
 arbitrary key/value pairs SHALL be provided. The value _V_ SHALL
 be optional.

State:: Methods for setting and returning the state of the resource
 SHALL be provided.

Aggregation:: A method for returning resource contents of composite
 object _in aggregate_ SHALL be provided. The _Aggregate_ method SHALL
 return the sum of available resources by type name. Resources with an
 available count of 0 SHALL be pruned from the results by default,
 since the composite model implies that all children of an unavailable
 resource are themselves not available.

=== Find and Stage Methods

Match:: A method or set of methods for resource pool matching SHALL be
 provided by the implementation. Resource pools SHALL be matched on
 tags, properties, size, type, name, basename, ids, etc.

Traversal:: A method for traversal SHALL be provided to visit each
 node in the hierarchy rooted at the current object. The traversal
 method SHALL allow for optionally provided methods for determining
 the traversal pattern for each child resources. This interface SHALL
 allow, at least, the pruning of non-matching subtrees and the order
 of visitation of children during traversal.

Find:: A search method SHALL be provided by the implementation to
 traverse the tree and return all matching resource pools, along with
 their children, as well as ancestors up to the root of the hierarchy.
 The _Find_ method MAY be implemented as a combination of _Traversal_
 and _Match_.

=== Job Allocations and Reservations

Allocated:: A method to query the number of objects _allocated_ to
 jobs from the current pool SHALL be provided.

Available:: A method to query the current number of available members
 in a resource pool object SHALL be provided. The _available_ count
 MAY be calculated as _size_ - _allocated_.

Allocate (N, S):: Allocate _N_ resources from the pool
 under the name _S_. The available resources in a pool is
 its size minus the total number of allocations. The allocation
 _S_ SHALL be stored as a searchable attribute along with
 the resource for later use with _Find_ and _Match_ methods. If an
 allocation under _S_ already exists, then the allocation
 SHALL be grown by amount _N_.

Free (S, [N]):: Free the allocation named _S_ from the current pool
 and return all allocated items to the list of available resources.
 Optional argument _N_ SHALL shrink the allocation by _N_ items, where
 _N_ is less than or equal to total allocation under name _S_.

=== Resource Allocation Records

* One `unit` of the `size` resource pool SHALL be the most granular
  allocatable resource.  Multiple jobs may be allocated `size` units
  of a resource, but no two jobs MAY be allocated the same resource
  unit.  In other words, the total number of resource units allocated
  to jobs MAY not exceed the `size` count defined for the resource.

* When all `size` elements of a resource pool have been allocated to a
  job, the resource is allocated exclusively to the job.  The `shared`
  list of an exclusively allocated resource MUST be empty.

* By definition, when a resource is allocated exclusively to a job,
  all of its child resources MUST implicitly be allocated to the job.
  To save processing effort, child resources SHOULD NOT be given
  resource allocations or reservations when the parent resource is
  allocated exclusively to a job.  The allocation or reservation of
  the parent's job is implied.

* When a composite resource is allocated to a job, the job ID MUST be
  added to the `shared` list of each parent resource.  This allows a
  scheduler to quickly determine when a parental resource and all its
  children can be allocated exclusively to a job.
